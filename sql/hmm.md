#### List indexes
* From [here](https://www.postgresqltutorial.com/postgresql-indexes/postgresql-list-indexes/)
```sql
SELECT
    tablename,
    indexname,
    indexdef
FROM
    pg_indexes
WHERE
    schemaname = 'public'
    
ORDER BY
    tablename,
    indexname;

```

#### Disk Usage per table

* from [the postgresql wiki](https://wiki.postgresql.org/wiki/Disk_Usage)
* except one minor change ... for `('user_blah', 'user_blar', 'schema1', 'schema2')` schemas only ... 
```sql
SELECT *, pg_size_pretty(total_bytes) AS total
    , pg_size_pretty(index_bytes) AS INDEX
    , pg_size_pretty(toast_bytes) AS toast
    , pg_size_pretty(table_bytes) AS TABLE
  FROM (
  SELECT *, total_bytes-index_bytes-COALESCE(toast_bytes,0) AS table_bytes FROM (
      SELECT c.oid,nspname AS table_schema, relname AS TABLE_NAME
              , c.reltuples AS row_estimate
              , pg_total_relation_size(c.oid) AS total_bytes
              , pg_indexes_size(c.oid) AS index_bytes
              , pg_total_relation_size(reltoastrelid) AS toast_bytes
          FROM pg_class c
          LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
          WHERE relkind = 'r'
          and nspname in ('user_blah', 'user_blar', 'schema1', 'schema2')
  ) a
) a
```



#### detect blocked queries?

* This didnt exactly work for me as expected, but colleague had mentioned this ... 
```sql
SELECT
  COALESCE(blockingl.relation::regclass::text,blockingl.locktype) as locked_item,
  now() - blockeda.query_start AS waiting_duration, blockeda.pid AS blocked_pid,
  blockeda.query as blocked_query, blockedl.mode as blocked_mode,
  blockinga.pid AS blocking_pid, blockinga.query as blocking_query,
  blockingl.mode as blocking_mode
FROM pg_catalog.pg_locks blockedl
JOIN pg_stat_activity blockeda ON blockedl.pid = blockeda.pid
JOIN pg_catalog.pg_locks blockingl ON(
  ( (blockingl.transactionid=blockedl.transactionid) OR
  (blockingl.relation=blockedl.relation AND blockingl.locktype=blockedl.locktype)
  ) AND blockedl.pid != blockingl.pid)
JOIN pg_stat_activity blockinga ON blockingl.pid = blockinga.pid
  AND blockinga.datid = blockeda.datid
WHERE NOT blockedl.granted
AND blockinga.datname = current_database()


```



#### hmmmm how about this

```sql
select blockingl.relation, blockingl.pid, blockingl.mode, blockingl.granted,
        pgclass.relname, stat.usename, stat.application_name, stat.wait_event_type, stat.wait_event, stat.state, stat.query
    from pg_catalog.pg_locks blockingl
    join pg_class pgclass on blockingl.relation = pgclass.oid 
    join pg_stat_activity stat on stat.pid = blockingl.pid 

```


#### check role membership

```sql
select rr.*, pam.* from pg_catalog.pg_roles rr 
 join pg_catalog.pg_auth_members pam on rr."oid" = pam.roleid 
 
```


#### in line table
* using a CTE ...
```sql
with datar(col1,col2) as (
    values (1,2), (2,3), (4,5)
    )
select col1, col2 from datar

```

#### COALESCE uses early stopping
* I had a pretty expensive `COALESCE(col1, col2, ..., col50)` with 50 arguments recently. And in testing whether my non-null value was first or last made a big difference!


#### round does not work on double precision
* Wow interesting. I was comparing features generated in two tables to do some QA. Table 1 was the original or "target gold" table and table 2 was a table generated by production code. Using a simple `table1.col1 = table2.col1` comparison, a particular float column was coming back as `0.092` , for about `100k` rows. Hand inspecting, this looked like a difference of precision, but when I applied `round(table1.col1, 3) = round(table2.col1, 3)` instead, I got 

```
UndefinedFunction: function round(double precision, integer) does not exist
```
And surely enough after reading the [docs](https://www.postgresql.org/docs/9.6/functions-math.html) , oddly enough `round` with precision is only defined for `numeric` and not `float8` (aka `double precision`). After casting to `numeric` my result of `round(table1.col1::numeric, 3) = round(table2.col1::numeric, 3)` was `0.990`. Can dig deeper about the implementation later!

#### To infinity and beyond

```sql
select 999999> 'infinity'::float 
```

#### unnesting , the opposite of crosstab (aka pivoting)

```sql
CREATE  TABLE foo (id int, a text, b text, c text);
INSERT INTO foo VALUES (1, 'ant', 'cat', 'chimp'), (2, 'grape', 'mint', 'basil'),
                        (3, 'blur', 'cart', 'jump');
```
```sql
select * from foo
```

id|a|b|c
--|--|--|--
1|ant|cat|chimp
2|grape|mint|basil
3|blur|cart|jump

```
SELECT id,
       unnest(array['a', 'b', 'c']) AS colname,
       unnest(array[a, b, c]) AS thing
FROM foo
ORDER BY id;
```


id|colname|thing
--|--|--
1|a|ant
1|b|cat
1|c|chimp
2|a|grape
2|b|mint
2|c|basil
3|a|blur
3|b|cart
3|c|jump

#### copy paste a table with create table as
* Copy-pastaing a table with `CREATE TABLE AS` is sort of obvious, but laying it out doesn't hurt

```sql
CREATE TABLE blah_backup AS
SELECT *
FROM source_table

```

* [cool stack overflow response here too](https://dba.stackexchange.com/questions/156105/create-table-as-vs-select-into?newreg=f13041cd0d564c7f97956cde8793af0e)

